# Move-семантика и базовая многопоточность

## [Задание по программированию: Считалка Иосифа](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Red%20Belt/Week_5/Task_1)

Дан диапазон объектов некоторого типа. Напишите функцию, переставляющую его элементы в соответствии с порядком, определённым так называемой считалкой Иосифа с заданным размером шага:
```cpp
template <typename RandomIt>
void MakeJosephusPermutation(
    RandomIt range_begin, RandomIt range_end,
    uint32_t step_size
);
```

Гарантируется, что итераторы range_begin и range_end являются итераторами произвольного доступа, то есть допускают вычитание одного из другого и сложение с числом. Кроме того, вы можете полагаться на то, что step_size > 0. Тип переупорядочиваемых объектов можно получить с помощью выражения typename RandomIt::value_type. Объекты этого типа запрещено копировать. При наличии копирования этих объектов вы получите ошибку компиляции.

Ограничения

Максимальный размер диапазона — 10^5, максимальный размер шага — 10^2. Время выполнения одного вызова функции ограничено 1 секундой.

Решение с копированиями

Вам дано решение данной задачи, копирующее элементы и не укладывающееся в ограничения по времени, но в остальном корректное. Вы можете исправить его или написать своё.

## [Тренировочное задание по программированию: Группировка строк](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Red%20Belt/Week_5/Task_2)

Дан набор строк. Необходимо разбить их на группы, в каждой из которых все строки имеют одинаковый набор символов.

Например, если даны строки **law, port, top, laptop, pot, paloalto, wall, awl**, нужно разбить их на 4 группы:

* строки, состоящие только из букв a, l и w: law, wall, awl;
* строки, состоящие только из букв o, p, r и t: port;
* строки, состоящие только из букв o, p и t: top, pot;
* строки, состоящие только из букв a, l, o, p, t: laptop, paloalto.

Разбиение на группы должно быть реализовано в виде функции
```cpp
template <typename String>
vector<Group<String>> GroupHeavyStrings(vector<String> strings);
```

Здесь Group<String> — синоним для vector<String>:
```cpp
template <typename String>
using Group = vector<String>;
```

Наличие такого синонима позволяет записать возвращаемый тип функции GroupHeavyString в виде vector<Group<String>>, что читается понятнее, чем vector<vector<String>>.

Слова в каждой группе должны располагаться в том же порядке, что и в исходном наборе. При этом порядок самих групп значения не имеет.

Строка типа String не обязана состоять из символов типа char. Тип символа можно получить с помощью выражения typename String::value_type или Char<String>, если определить соответствующий синоним:
```cpp
template <typename String>
using Char = typename String::value_type;
```

Сам тип String может быть, например, обычной строкой (string) или вектором символов.

Про тип Char<String> известно следующее:

* Объекты этого типа можно сравнивать с помощью операторов == и <.
* «Тяжёлыми» могут быть не только сами строки, но и отдельные символы. Поэтому их можно свободно перемещать, но скопировать каждый символ в функции можно не более одного раза (без учёта копирования при передаче аргумента strings по значению). В противном случае вы получите вердикт «неправильный ответ» с соответствующим комментарием.

Ограничения

За 1 секунду функция должна обработать максимум 100000 строк длины не более 100. При оценке сложности можете считать, что копирование каждого символа стоит порядка 100 элементарных операций.

## [Тренировочное задание по программированию: Оператор присваивания для SimpleVector](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Red%20Belt/Week_5/Task_3)

В видеолекции мы с вами познакомились с конструктором копирования и оператором присваивания, а также написали конструктор копирования для SimpleVector. В этой задаче вам нужно реализовать оператор присваивания для SimpleVector.

Напомним, что следующий код вызывает **конструктор копирования**:
```cpp
SimpleVector<int> source(5);
SimpleVector<int> dest = source; // Конструктор копирования
```

А код ниже — **оператор присваивания**:
```cpp
SimpleVector<int> source(5);
SimpleVector<int> dest;
dest = source; // Оператор присваивания
```

Вам дан cpp-файл, который подключает заголовочный файл simple_vector.h и содержит небольшой набор юнит-тестов. Пришлите на проверку файл simple_vector.h с реализацией оператора присваивания.

## [Задание по программированию: Разбиение на предложения](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Red%20Belt/Week_5/Task_4)

Дан вектор токенов. Напишите функцию, разбивающую токены на предложения:
```cpp
template <typename Token>
vector<Sentence<Token>> SplitIntoSentences(vector<Token> tokens);
```

Token — шаблонный тип, про который известно лишь то, что он имеет константный метод IsEndSentencePunctuation, возвращающий true, если токен является знаком пунктуации, заканчивающим предложение, и false в противном случае. Объекты этого типа запрещено копировать. При наличии копирования этих объектов вы получите ошибку компиляции.

Sentence — синоним для типа vector, объявленный следующим образом:
```cpp
// Объявляем Sentence<Token> для произвольного типа Token
// синонимом vector<Token>.
// Благодаря этому в качестве возвращаемого значения
// функции можно указать не малопонятный вектор векторов,
// а вектор предложений — vector<Sentence<Token>>.
template <typename Token>
using Sentence = vector<Token>;
```

Предложением считается последовательность токенов, заканчивающаяся подряд идущими токенами, являющимися знаками пунктуации конца предложения. Иными словами, любое предложение должно состоять из двух частей:

* токены, для которых IsEndSentencePunctuation возвращает false (такие токены обязаны присутствовать в предложении за исключением, возможно, первого предложения);
* токены, для которых IsEndSentencePunctuation возвращает true (такие токены обязаны присутствовать в предложении за исключением, возможно, последнего предложения).

Ограничения

Максимальное количество токенов — 10^6. Время выполнения одного вызова функции ограничено 1 секундой.

## [Тренировочное задание по программированию: Move-семантика в SimpleVector](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Red%20Belt/Week_5/Task_5)

Решите задачу «Реализовать свой вектор» со следующими дополнительными требованиями:

* метод PushBack должен позволять добавить элемент в вектор с помощью перемещения;
* никакие методы вектора не должны осуществлять копирование элементов.

Таким образом, должен получиться вектор, позволяющий хранить некопируемые объекты.

Шаблон решения содержит юнит-тест, проверяющий работу вектора, состоящего из некопируемых строк. Если вектор будет осуществлять копирования, благодаря указанному юнит-тесту **решение не скомпилируется**.

## [Задание по программированию: Сортировка слиянием — 3](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Red%20Belt/Week_5/Task_6)

Замечание

Задачи «Сортировка слиянием» и «Сортировка слиянием — 2» были в «Жёлтом поясе по С++»

Условие

Напишите шаблонную функцию MergeSort, принимающую два итератора шаблонного типа RandomIt и сортирующую заданный ими диапазон с помощью сортировки слиянием. Гарантируется, что:
* итераторы типа RandomIt аналогичны по функциональности итераторам вектора и строки, то есть их можно сравнивать с помощью операторов <, <=, > и >=, а также вычитать и складывать с числами;
* сортируемые объекты можно сравнивать с помощью оператора <.

```cpp
template <typename RandomIt>
void MergeSort(RandomIt range_begin, RandomIt range_end);
```

Алгоритм

В этой задаче вы должны реализовать точь-в-точь алгоритм, представленный ниже; тестирующая система будет проверять, что вы выполняете с элементами именно эти действия:
* Если диапазон содержит меньше 2 элементов, выйти из функции.
* Создать вектор, содержащий все элементы текущего диапазона.
* Разбить вектор на три равные части. (В этой задаче гарантируется, что длина передаваемого диапазона является степенью тройки, так что вектор всегда можно разбить на три равные части.)
* Вызвать функцию MergeSort от каждой части вектора.
* Слить первые две трети вектора с помощью алгоритма merge, сохранив результат во временный вектор с помощью back_inserter.
* Слить временный вектор из предыдущего пункта с последней третью вектора из п. 2, записав полученный отсортированный диапазон вместо исходного.

В процессе работы вашего алгоритма не должно происходить копирования сортируемых элементов. Если вы используете копирование, при отправке не проверку решение не скомпилируется.

## [Задание по программированию: Контейнер с приоритетами]()

### Условие задачи
Реализуйте шаблонный контейнер PriorityCollection, позволяющий хранить объекты некопируемого типа, а также совершать с ними следующие операции:
* добавить элемент с нулевым приоритетом;
* добавить набор элементов с нулевыми приоритетами;
* увеличить на 1 приоритет заданного элемента;
* извлечь из контейнера элемент с максимальным приоритетом.

Поскольку добавление элемента заключается в его перемещении в контейнер, метод увеличения приоритета не может принимать сам элемент. Поэтому метод, добавляющий элементы, для каждого из них должен вернуть некий идентификатор, который затем можно использовать для вызова других методов.

Тип идентификатора — PriorityCollection::Id — вы должны выбрать самостоятельно. Он должен быть легко копируемым: например, числом, указателем или итератором. Примеры определения и использования типа Id вы можете найти в шаблоне решения.

### Структура класса
```cpp
template <typename T>
class PriorityCollection {
public:
  using Id = /* тип, используемый для идентификаторов */;

  // Добавить объект с нулевым приоритетом
  // с помощью перемещения и вернуть его идентификатор
  Id Add(T object);

  // Добавить все элементы диапазона [range_begin, range_end)
  // с помощью перемещения, записав выданные им идентификаторы
  // в диапазон [ids_begin, ...)
  template <typename ObjInputIt, typename IdOutputIt>
  void Add(ObjInputIt range_begin, ObjInputIt range_end,
           IdOutputIt ids_begin);

  // Определить, принадлежит ли идентификатор какому-либо
  // хранящемуся в контейнере объекту
  bool IsValid(Id id) const;

  // Получить объект по идентификатору
  const T& Get(Id id) const;

  // Увеличить приоритет объекта на 1
  void Promote(Id id);

  // Получить объект с максимальным приоритетом и его приоритет
  pair<const T&, int> GetMax() const;

  // Аналогично GetMax, но удаляет элемент из контейнера
  pair<T, int> PopMax();

private:
  // Приватные поля и методы
};
```

### Гарантии
1. Вы можете полагаться на то, что для элементов типа T определены перемещение и сравнение на ==, != и <. Все операции над элементами имеют константную сложность.
2. Гарантируется, что все добавляемые элементы различны, однако добавленный и затем извлечённый элемент может быть добавлен вновь.
3. Методы Get и Promote всегда вызываются от валидных с точки зрения метода IsValid идентификаторов.
4. Методы GetMax и PopMax вызываются только при наличии элементов в контейнере.
5. При наличии нескольких элементов с одинаковым максимальным приоритетом необходимо выбирать и извлекать тот, который был добавлен позже остальных.

### Ограничения
Контейнер должен обрабатывать 10^6 запросов не более чем за 1 секунду. Гарантируется, что суммарная длина диапазонов, с которыми вызывается вторая версия метода Add, также не превосходит 10^6.

## [Тренировочное задание по программированию: Суммирование матрицы]()

В лекциях мы рассмотрели пример, в котором сначала выполнялась генерация квадратной матрицы, а затем находилась сумма элементов в ней. При этом нам удалось ускорить генерацию матрицы за счёт применения многопоточности. В этой задаче вам нужно сделать то же самое для суммирования элементов матрицы.

Вам нужно написать функцию int64_t CalculateMatrixSum(const vector<vector<int>>& matrix), которая получает на вход квадратную матрицу и возвращает сумму элементов в ней.

Ваша реализация будет тестироваться следующим образом:
* на вход вашей функции будут подаваться квадратные матрицы размером до 9000 (в данном случае размер матрицы — это количество строк в ней);
* для одной и той же матрицы функция CalculateMatrixSum будет запускаться несколько раз; среднее время работы одного вызова в нашей тестирующей системе не должно превышать 15 мс;

## [Задание по программированию: Исследование блогов]()

Крупная IT-компания Янгл проводит исследование упоминаемости своего бренда в блогах и социальных сетях. Аналитики компании уже выгрузили интересующие их публикации и сформировали набор ключевых слов. Их интересует, сколько раз каждое ключевое слово входит в набор публикаций.

Помогите им это сделать — напишите функцию Stats ExploreKeyWords(const set<string>& key_words, istream& input). Её параметры:

* key_words — множество ключевых слов
* input — входной поток, содержащий исследуемые публикации в блогах и соц. сетях, одна строка — одна публикация.

Функция ExploreKeyWords должна возвращать структуру Stats, в которой хранится, сколько раз каждое слово из key_words суммарно встретилось в потоке input:
```cpp
struct Stats {
  map<string, int> word_frequences;

  void operator += (const Stats& other);
};
```

При подсчёте вхождения ключевых слов в текст нужно учитывать только вхождения в виде отдельных слов. Слова друг от друга отделяются одним или несколькими пробелами. В качестве примера допустим, что key_words = {"yangle", "rocks", "sucks", "all"} и у нас есть публикация из соц. сети Switter: "Goondex really sucks, but yangle rocks ! Use yangle". Слово «yangle» входит в неё 2 раза, «rocks» — один раз, а слова «all» и «sucks» — ни разу. Слово «sucks» не входит ни разу, потому что в данном примере оно является префиксом слова «sucks,» (по условию, слова друг от друга отделяются только пробелами). Несмотря на то, что слово «all» является частью слова «really», его вхождение тоже нельзя засчитывать, так как это не отдельное слово.

Чтобы уложиться в Time Limit, подумайте, можно ли эту задачу распараллелить.

Замечание

До этого в лекциях мы показывали, как использовать функцию async для асинхронного запуска лямбда-функций без параметров. Однако её можно использовать и для запуска функций, у которых есть параметры. Например,

```cpp
string Join(string s, string t) {
  return s + t;
}

string a = "Hello";
string b = " world";
future<string> f = async(Join, a, b);
```

Как видите, чтобы передать параметры в функцию, запускаемую асинхронно, их надо указать в качестве параметров функции async после самой функции. Важно отметить, что при таком вызове будут созданы копии фактических параметров (т.е. в нашем примере выше строки a и b будут скопированы). Это не всегда желательно. Например, если у нас есть константный объект, который потоки только читают, у нас нет необходимости создавать его копию, и можно передать его по ссылке. Для этого надо воспользоваться функцией ref из заголовочного файла <functional>.
```cpp
Stats ExploreKeyWordsSingleThread(const set<string>& key_words, istream& input);

Stats ExploreKeyWords(const set<string>& key_words, istream& input) {
  // key_words и input будут переданы по ссылке, а не скопированы
  return async(ExploreKeyWordsSingleThread, ref(key_words), ref(input)).get();
}
```

## [Тренировочное задание по программированию: Шаблон Synchronized]()

Мы уже не раз видели, что отсутствие синхронизации доступа нескольких потоков к одним и тем же данным может фатально сказаться на работе программы. Поэтому очень важно не забывать захватывать мьютекс при обращении к разделяемым данным. Но если у нас есть большой проект, в котором доступ к общим данным осуществляется из большого количества мест в коде, то не так уж и трудно забыть сделать это, внося очередные правки.

Чтобы защититься от такой забывчивости, можно написать специальную обёртку над данными, которая будет предоставлять к ним доступ только под мьютексом. В этой задаче вам надо разработать такую обёртку — шаблон класса Synchronized вот с таким интерфейсом:
```cpp
template <typename T>
class Synchronized {
public:
  explicit Synchronized(T initial = T());

  struct Access {
    T& ref_to_value;
  };

  Access GetAccess();
private:
  T value;
};
```

Тип Access должен быть структурой, в которой есть поле T& ref_to_value, ссылающееся на поле value класса Synchronized<T>. Кроме того объект класса Access должен вести себя аналогично классу lock_guard<mutex>: захватывать мьютекс в своём конструкторе и освобождать в деструкторе. Пример:
```cpp
Synchronized<int> s_int;
{
  auto access = s_int.GetAccess();
  // Критическая секция начинается отсюда и продолжается до конца блока
  access.ref_to_value = 5;
}
ASSERT_EQUAL(s_int.GetAccess().value, 5);
```

Вам можно (и даже нужно) добавлять необходимые поля в класс Access и шаблон Synchronized. Более подробные примеры использования шаблона Synchronized смотрите в заготовке решения.

Как видите, единственный способ получить доступ к полю value класса Synchronized<T> — это обратиться к полю ref_to_value класса Access, который гарантирует, что этот доступ осуществляется под мьютексом. Таким образом, если разделяемые данные обернуть в шаблон Synchronized, вы никогда не забудете захватить мьютекс при обращении к ним.

## [Задание по программированию: ConcurrentMap]()

В заготовке решения задачи «Шаблон Synchronized» мы уже слегка коснулись идеи о том, что уменьшение размера критической секции позволяет повысить скорость работы многопоточной программы. В этой задаче мы разовьём её больше.

Давайте представим, что у нас есть map, к которому обращаются несколько потоков. Чтобы синхронизировать доступ к нему, мы можем каждое обращение к этому map'у защитить мьютексом (например, завернув наш map в шаблон Synchronized). Теперь давайте представим, что у нас есть Synchronized<map<int, int>>, в котором хранятся все ключи от 1 до 10000. Интуитивно кажется, что когда из одного потока мы обращаемся к ключу 10, а из другого — например, к ключу 6712, то нет смысла защищать эти обращения одним и тем же мьютексом. Это отдельные области памяти, а внутреннюю структуру словаря мы никак не изменяем. При этом, если мы будем обращаться к ключу 6712 одновременно из нескольких потоков, то синхронизация, несомненно, понадобится.

Отсюда возникает идея — разбить наш словарь на нескольких подсловарей с непересекающимся набором ключей и защитить каждый из них отдельным мьютексом. Тогда при обращении разных потоков к разным ключам они нечасто будут попадать в один и тот же подсловарь, а значит, смогут параллельно его обрабатывать. Эту идею вам предстоит реализовать в этой задаче. Вам надо написать шаблон класса ConcurrentMap вот с таким интерфейсом:
```cpp
template <typename K, typename V>
class ConcurrentMap {
public:
  static_assert(is_integral_v<K>, "ConcurrentMap supports only integer keys");

  struct Access {
    V& ref_to_value;
  };

  explicit ConcurrentMap(size_t bucket_count);

  Access operator[](const K& key);

  map<K, V> BuildOrdinaryMap();
};
```

* static_assert в начале класса говорит, что в данной задаче предполагается, что ключами ConcurrentMap'а могут быть только целые числа.
* Конструктор класса ConcurrentMap<K, V> принимает количество подсловарей, на которые надо разбить всё пространство ключей.
* operator[] должен вести себя так же, как аналогичный оператор у map — если ключ key присутствует в словаре, он должен возвращать объект класса Access, содержащий ссылку на соответствующее ему значение; если же key отсутствует в словаре, в него надо добавить пару (key, V()) и вернуть объект класса Access, содержащий ссылку на только что добавленное значение.
* Структура Access, должна вести себя так же, как и в шаблоне Synchronized, — предоставлять ссылку на значение словаря и обеспечивать синхронизацию доступа к нему.
* Метод BuildOrdinaryMap должен сливать вместе части словаря и возвращать весь словарь целиком. При этом он должен быть потокобезопасным, то есть корректно работать, когда другие потоки выполняют операции с ConcurrentMap.
