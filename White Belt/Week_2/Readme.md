# Знакомство с искусством C++

## [Задание по программированию: Факториал](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_1)

Напишите функцию, которая:
* называется Factorial
* возвращает int
* принимает int и возвращает факториал своего аргумента.
Гарантируется, что аргумент функции по модулю не превышает 10.
Для отрицательных аргументов функция должна возвращать 1.

## [Тренировочное задание по программированию: Палиндром](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_2)

Напишите функцию, которая:
* называется IsPalindrom
* возвращает bool
* принимает параметр типа string и возвращает, является ли переданная строка палиндромом
Палиндром - это слово или фраза, которые одинаково читаются слева направо и справа налево.
Пустая строка является палиндромом.

## [Задание по программированию: Отбор палиндромов](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_3)

Напишите функцию, которая:
* называется PalindromFilter
* возвращает vector<string>
* принимает vector<string> words и int minLength и возвращает все строки из вектора words,
которые являются палиндромами и имеют длину не меньше minLength

Входной вектор содержит не более 100 строк, длина каждой строки не больше 100 символов.

## [Тренировочное задание по программированию: Максимизатор](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_4)

Напишите функцию UpdateIfGreater, которая принимает два целочисленных аргумента: first и second.
Если first оказался больше second, Ваша функция должна записывать в second значение параметра first.
При этом указанная функция не должна ничего возвращать, а изменение параметра second должно быть видно на вызывающей стороне.

## [Задание по программированию: Перемещение строк](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_5)

Напишите функцию MoveStrings, которая принимает два вектора строк, source и destination,
и дописывает все строки из первого вектора в конец второго.
После выполнения функции вектор source должен оказаться пустым.

## [Задание по программированию: Разворот последовательности](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_6)

Реализуйте функцию void Reverse(vector<int>& v), которая переставляет элементы вектора в обратном порядке.

## [Тренировочное задание по программированию: Разворот последовательности — 2](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_7)

Реализуйте функцию vector<int> Reversed(const vector<int>& v), возвращающую копию вектора v, в которой числа переставлены в обратном порядке.

## [Тренировочное задание по программированию: Средняя температура](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_8)

Даны значения температуры, наблюдавшиеся в течение N подряд идущих дней.
Найдите номера дней (в нумерации с нуля) со значением температуры выше среднего арифметического за все N дней.

Гарантируется, что среднее арифметическое значений температуры является целым числом.

### **Формат ввода**
Вводится число N, затем N неотрицательных целых чисел — значения температуры в 0-й, 1-й, ... (N−1)-й день.

### **Формат вывода**
Первое число K — количество дней, значение температуры в которых выше среднего арифметического.
Затем K целых чисел — номера этих дней.

## [Задание по программированию: Очередь](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_9)

Люди стоят в очереди, но никогда не уходят из её начала, зато могут приходить в конец и уходить оттуда.
Более того, иногда некоторые люди могут прекращать и начинать беспокоиться из-за того, что очередь не продвигается.

Реализуйте обработку следующих операций над очередью:

* **WORRY i**: пометить i-го человека с начала очереди (в нумерации с 0) как беспокоящегося;
* **QUIET i**: пометить i-го человека как успокоившегося;
* **COME k**: добавить k спокойных человек в конец очереди;
* **COME -k**: убрать k человек из конца очереди;
* **WORRY_COUNT**: узнать количество беспокоящихся людей в очереди.

Изначально очередь пуста.

### ***Формат ввода**
Количество операций Q, затем описания операций.

Для каждой операции **WORRY i** и **QUIET i** гарантируется, что человек с номером i существует в очереди на момент операции.

Для каждой операции **COME -k** гарантируется, что k не больше текущего размера очереди.

### **Формат вывода**
Для каждой операции **WORRY_COUNT** выведите одно целое число — количество беспокоящихся людей в очереди.

## [Задание по программированию: Ежемесячные дела](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_10)

У каждого из нас есть повторяющиеся ежемесячные дела, каждое из которых нужно выполнять в конкретный день каждого месяца:
оплата счетов за электричество, абонентская плата за связь и пр.
Вам нужно реализовать работу со списком таких дел на месяц, а именно, реализовать набор следующих операций:

### **ADD i s**
Назначить дело с названием s на день i текущего месяца.

### **DUMP i**
Вывести все дела, запланированные на день i текущего месяца.

### **NEXT**
Перейти к списку дел на новый месяц.
При выполнении данной команды вместо текущего (старого) списка дел на текущий месяц создаётся и становится активным (новый)
список дел на следующий месяц: все дела со старого списка дел копируются в новый список.
После выполнения данной команды новый список дел и следующий месяц становятся текущими,
а работа со старым списком дел прекращается.
При переходе к новому месяцу необходимо обратить внимание на разное количество дней в месяцах:

* если следующий месяц имеет больше дней, чем текущий, «дополнительные» дни необходимо оставить пустыми (не содержащими дел);
* если следующий месяц имеет меньше дней, чем текущий, меньше дней, дела со всех «лишних» дней необходимо переместить на последний день следующего месяца.

### **Замечания**
* Историю списков дел хранить не требуется, работа ведется только с текущим списком дел текущего месяца.
Более того, при создании списка дел на следующий месяц, он «перетирает» предыдущий список.
* Обратите внимание, что количество команд NEXT в общей последовательности команд при работе со списком дел может превышать 11.
* Начальным текущим месяцем считается январь.
* Количества дней в месяцах соответствуют Григорианскому календарю с той лишь разницей, что в феврале всегда 28 дней.
### **Формат ввода**
Сначала число операций Q, затем описания операций.

Названия дел s уникальны и состоят только из латинских букв, цифр и символов подчёркивания.
Номера дней i являются целыми числами и нумеруются от 1 до размера текущего месяца.

### **Формат вывода**
Для каждой операции типа DUMP в отдельной строке выведите количество дел в соответствующий день,
а затем их названия, разделяя их пробелом. Порядок вывода дел в рамках каждой операции значения не имеет.

## [Тренировочное задание по программированию: Анаграммы](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_11)

Слова называются анаграммами друг друга, если одно из них можно получить перестановкой букв в другом.
Например, слово «eat» можно получить перестановкой букв слова «tea», поэтому эти слова являются анаграммами друг друга.
Даны пары слов, проверьте для каждой из них, являются ли слова этой пары анаграммами друг друга.

### **Указание**
Один из способов проверки того, являются ли слова анаграммами друг друга, заключается в следующем.
Для каждого слова с помощью словаря подсчитаем, сколько раз в нём встречается каждая буква.
Если для обоих слов эти словари равны (а это проверяется с помощью обычного оператора ==),
то слова являются анаграммами друг друга, в противном случае не являются.

При этом построение такого словаря по слову удобно вынести в отдельную функцию BuildCharCounters.

### **Формат ввода**
Сначала дано число пар слов N, затем в N строках содержатся пары слов, которые необходимо проверить.
Гарантируется, что все слова состоят лишь из строчных латинских букв.

### **Формат вывода**
Выведите N строк: для каждой введённой пары слов **YES**, если эти слова являются анаграммами, и **NO** в противном случае.

## [Тренировочное задание по программированию: Справочник столиц](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_12)

Реализуйте справочник столиц стран.

На вход программе поступают следующие запросы:

* **CHANGE_CAPITAL** ***country new_capital*** — изменение столицы страны country на new_capital,
либо добавление такой страны с такой столицей, если раньше её не было.
* **RENAME** ***old_country_name new_country_name*** — переименование страны из old_country_name в new_country_name.
* **ABOUT** ***country*** — вывод столицы страны country.
* **DUMP** — вывод столиц всех стран.

### **Формат ввода**
В первой строке содержится количество запросов Q, в следующих Q строках — описания запросов.
Все названия стран и столиц состоят лишь из латинских букв, цифр и символов подчёркивания.

### **Формат вывода**
Выведите результат обработки каждого запроса:

В ответ на запрос **CHANGE_CAPITAL** ***country new_capital*** выведите
* **Introduce new country** ***country*** **with capital** ***new_capital***, если страны ***country*** раньше не существовало;
* **Country** ***country*** **hasn't changed its capital**, если страна ***country*** до текущего момента имела столицу ***new_capital***;
* **Country** ***country*** **has changed its capital from** ***old_capital*** **to** ***new_capital***,
если страна ***country*** до текущего момента имела столицу ***old_capital***, название которой не совпадает с названием ***new_capital***.

В ответ на запрос **RENAME** ***old_country_name new_country_name*** выведите
* **Incorrect rename, skip**, если новое название страны совпадает со старым,
страна ***old_country_name*** не существует или страна ***new_country_name*** уже существует;
* **Country** ***old_country_name*** **with capital** ***capital*** **has been renamed to** ***new_country_name***,
если запрос корректен и страна имеет столицу ***capital***.

В ответ на запрос **ABOUT** ***country*** выведите
* **Country** ***country*** **doesn't exist**, если страны с названием ***country*** не существует;
* **Country** ***country*** **has capital** ***capital***, если страна ***country*** существует и имеет столицу ***capital***.

В ответ на запрос **DUMP** выведите
* **There are no countries in the world**, если пока не было добавлено ни одной страны;
* последовательность пар вида ***country/capital***, описывающую столицы всех стран, если в мире уже есть хотя бы одна страна.
При выводе последовательности пары указанного вида необходимо упорядочить по названию страны и разделять между собой пробелом.

## [Задание по программированию: Автобусные остановки — 1](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_13)

Реализуйте систему хранения автобусных маршрутов.
Вам нужно обрабатывать следующие запросы:

* **NEW_BUS** ***bus stop_count stop1 stop2 ...*** — добавить маршрут автобуса
с названием bus и stop_count остановками с названиями ***stop1, stop2, ...***
* **BUSES_FOR_STOP** ***stop*** — вывести названия всех маршрутов автобуса, проходящих через остановку ***stop***.
* **STOPS_FOR_BUS** ***bus*** — вывести названия всех остановок маршрута bus со списком автобусов,
на которые можно пересесть на каждой из остановок.
* **ALL_BUSES** — вывести список всех маршрутов с остановками.

### **Формат ввода**
В первой строке ввода содержится количество запросов Q, затем в Q строках следуют описания запросов.

Гарантируется, что все названия маршрутов и остановок состоят лишь из латинских букв, цифр и знаков подчёркивания.

Для каждого запроса **NEW_BUS** ***bus stop_count stop1 stop2 ...*** гарантируется, 
что маршрут ***bus*** отсутствует, количество остановок больше 0,
а после числа ***stop_count*** следует именно такое количество названий остановок, причём все названия в каждом списке различны.

### **Формат вывода**
Для каждого запроса, кроме **NEW_BUS**, выведите соответствующий ответ на него:

* На запрос **BUSES_FOR_STOP** ***stop*** выведите через пробел список автобусов,
проезжающих через эту остановку, в том порядке, в котором они создавались командами **NEW_BUS**.
Если остановка ***stop*** не существует, выведите **No stop**.
* На запрос **STOPS_FOR_BUS** ***bus*** выведите описания остановок маршрута ***bus*** в отдельных строках в том порядке,
в котором они были заданы в соответствующей команде **NEW_BUS**. 
Описание каждой остановки ***stop*** должно иметь вид **Stop** ***stop: bus1 bus2 ...***,
где ***bus1 bus2 ...*** — список автобусов, проезжающих через остановку ***stop***,
в порядке, в котором они создавались командами **NEW_BUS**, за исключением исходного маршрута ***bus***.
Если через остановку ***stop*** не проезжает ни один автобус, кроме ***bus***,
вместо списка автобусов для неё выведите **no interchange**. Если маршрут ***bus*** не существует, выведите **No bus**.
* На запрос **ALL_BUSES** выведите описания всех автобусов в алфавитном порядке.
Описание каждого маршрута ***bus*** должно иметь вид **Bus** ***bus: stop1 stop2 ...***,
где ***stop1 stop2 ...*** — список остановок автобуса ***bus*** в порядке,
в котором они были заданы в соответствующей команде **NEW_BUS**. Если автобусы отсутствуют, выведите **No buses**.

## [Задание по программированию: Автобусные остановки — 2](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_14)

В этой задаче вам нужно присваивать номера автобусным маршрутам.

А именно, для каждого маршрута, заданного набором названий остановок,
нужно либо выдать новый номер (первому маршруту — 1, второму — 2 и т. д.),
либо вернуть номер существующего маршрута, которому соответствует такой набор остановок.

Наборы остановок, полученные друг из друга перестановкой остановок, считаются различными (см. пример).

### **Указание**
В C++ ключом словаря может быть не только число или строка, но и другой контейнер, например, vector.

### **Формат ввода**
Сначала вводится количество запросов Q, затем Q описаний запросов.

Каждый запрос представляет собой положительное количество остановок N, за которым следуют разделённые пробелом N различных названий остановок соответствующего маршрута. Названия остановок состоят лишь из латинских букв и символов подчёркивания.

### **Формат вывода**
Выведите ответ на каждый запрос в отдельной строке.

Если маршрут с данным набором остановок уже существует,
в ответ на соответствующий запрос выведите **Already exists for i**,
где i — номер маршрута с таким набором остановок.
В противном случае нужно выделить введённому набору остановок новый номер i и вывести его в формате **New bus i**.

## [Тренировочное задание по программированию: Количество уникальных строк](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_15)

Дан набор строк.
Найдите количество уникальных строк в этом наборе.

### **Формат ввода**
Сначала вводится количество строк N, затем — сами N строк, разделённые пробелом.
Все строки состоят лишь из латинских букв, цифр и символов подчёркивания.

### **Формат вывода**
Выведите единственное целое число — количество уникальных строк в данном наборе.

## [Тренировочное задание по программированию: Множество значений словаря](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_16)

Напишите функцию BuildMapValuesSet, принимающую на вход словарь map<int, string> и возвращающую множество значений этого словаря:
```cpp
set<string> BuildMapValuesSet(const map<int, string>& m) {
  // ...
}
```
## [Задание по программированию: Синонимы](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_17)

Два слова называются синонимами друг друга, если они имеют похожие значения.
Реализуйте следующие операции над словарём синонимов:

* **ADD** ***word1 word2*** — добавить в словарь пару синонимов (word1, word2).
* **COUNT** ***word*** — узнать количество синонимов слова ***word***.
* **CHECK** ***word1 word2*** — проверить, являются ли слова ***word1*** и ***word2*** синонимами.
Слова ***word1*** и ***word2*** считаются синонимами, если среди запросов **ADD** был хотя бы один запрос
**ADD** ***word1*** ***word2*** или **ADD** ***word2*** ***word1***.

### **Замечание**
Для упрощения, будем считать, что синонимы не обладают транзитивностью, то есть, если A - синоним B,
а B - синоним C, то из этого НЕ следует, что A - синоним C.

### **Формат ввода**
Сначала вводится количество запросов Q, затем Q строк с описаниями запросов.
Гарантируется, что в каждом запросе CHECK и ADD слова word1 и word2 различны.
Все слова состоят лишь из латинских букв, цифр и символов подчёркивания.

### **Формат вывода**
Для каждого запроса в соответствующей строке выведите ответ на него:

* В ответ на запрос **COUNT** ***word*** выведите единственное целое число — количество синонимов слова ***word***.
* В ответ на запрос **CHECK** ***word1*** ***word2*** выведите строку **YES**,
если ***word1*** и ***word2*** являются синонимами, и **NO** в противном случае.

## Задание по программированию: Автобусные остановки — 3](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/White%20Belt/Week_2/Task_18)
В этой задаче вам нужно присваивать номера автобусным маршрутам.

А именно, для каждого маршрута, заданного множеством названий остановок,
нужно либо выдать новый номер (первому маршруту — 1, второму — 2 и т. д.),
либо вернуть номер существующего маршрута, которому соответствует такое множество остановок.

В отличие от задачи «Автобусные остановки — 2», наборы остановок,
которые можно получить друг из друга перестановкой элементов или добавлением/удалением повторяющихся, следует считать одинаковыми.

### **Формат ввода**
Сначала вводится количество запросов Q, затем Q описаний запросов.

Каждый запрос представляет собой положительное количество остановок N,
за которым следуют разделённые пробелом N названий остановок соответствующего маршрута (не обязательно различных).
Названия остановок состоят лишь из латинских букв и символов подчёркивания.

### **Формат вывода**
Выведите ответ на каждый запрос в отдельной строке.

Если маршрут с данным набором остановок уже существует,
в ответ на соответствующий запрос выведите **Already exists for i**, где i — номер маршрута с таким набором остановок.
В противном случае нужно выделить введённому набору остановок новый номер i и вывести его в формате New bus i.
