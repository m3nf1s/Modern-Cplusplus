# Пространства имён и указатель this

## [Тренировочное задание по программированию: Загрузка расходов из формата XML](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_1)

В этой тренировочной задаче вам надо поддержать загрузку расходов из формата XML в нашей программе управления личными финансами. При этом вам надо воспользоваться готовой библиотекой работы с XML. Более конкретно, вам надо написать функцию vector<Spending> LoadFromXml(istream& input). Spending — это структура из вводной лекции:

```cpp
struct Spending {
  string category;
  int amount;
};
```

Поток input содержит описание расходов в формате XML, например:

```xml
<july>
  <spend amount="2500" category="food"></spend>
  <spend amount="1150" category="transport"></spend>
  <spend amount="5780" category="restaurants"></spend>
  <spend amount="7500" category="clothes"></spend>
  <spend amount="23740" category="travel"></spend>
  <spend amount="12000" category="sport"></spend>
</july>
```

Важно отметить:
* формат текста в потоке input всегда строго такой, как в примере: есть один корневой узел, который содержит несколько узлов <spend> с атрибутами "amount" и "category"
* функция Load из выданной вам библиотеки работы с XML умеет загружать описанный выше формат
* мы выдаём вам не реальную библиотеку разбора XML, а лишь минимальный код, достаточный для работы описанным форматом данных
* цель этой задачи — не показать, как правильно парсить XML, а познакомить вас с кодом, на котором мы в дальнейшем будем разбирать пространства имён, поэтому очень важно, чтобы вы реализовали функцию LoadFromXml через содержимое нашей библиотеки работы с XML.

На проверку пришлите cpp-файл, который подключает файл xml.h (дан ниже) и содержит реализацию функции LoadFromXml. Тестирующая система соберёт его вместе с файлом xml.cpp и прогонит набор юнит-тестов.

## [Тренировочное задание по программированию: Загрузка расходов из формата JSON](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_2)

В этой тренировочной задаче вам надо поддержать загрузку расходов из формата JSON в нашей программе управления личными финансами. При этом вам надо воспользоваться готовой библиотекой работы с JSON. Более конкретно, вам надо написать функцию vector<Spending> LoadFromJson(istream& input). Spending — это структура из вводной лекции:
```cpp
struct Spending {
  string category;
  int amount;
};
```
Поток input содержит описание расходов в формате JSON, например:
```json
[
  {"amount": 2500, "category": "food"},
  {"amount": 1150, "category": "transport"},
  {"amount": 5780, "category": "restaurants"},
  {"amount": 7500, "category": "clothes"},
  {"amount": 23740, "category": "travel"},
  {"amount": 12000, "category": "sport"}
]
```
Важно отметить:
* формат текста в потоке input всегда строго такой, как в примере: есть массив, который содержит несколько словарей с ключами "amount" и "category"
* функция Load из выданной вам библиотеки работы с JSON умеет загружать описанный выше формат
* мы выдаём вам не реальную библиотеку разбора JSON, а лишь минимальный код, достаточный для работы описанным форматом данных
* цель этой задачи — не показать, как правильно парсить JSON, а познакомить вас с кодом, на котором мы в дальнейшем будем разбирать пространства имён, поэтому очень важно, чтобы вы реализовали функцию LoadFromJson через содержимое нашей библиотеки работы с JSON.

На проверку пришлите cpp-файл, который подключает файл json.h (дан ниже) и содержит реализацию функции LoadFromJson. Тестирующая система соберёт его вместе с файлом json.cpp и прогонит набор юнит-тестов.

## [Задание по программированию: Библиотека работы с INI-файлами](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_3)

В лекциях мы разработали библиотеки для загрузки данных из форматов XML и JSON, поместив каждую из них в своё пространство имён. В этой задаче вам нужно сделать то же самое для формата INI. Вам надо разработать библиотеку со следующим интерфейсом
```cpp
using Section = unordered_map<string, string>;

class Document {
public:
  Section& AddSection(string name);
  const Section& GetSection(const string& name) const;
  size_t SectionCount() const;

private:
  unordered_map<string, Section> sections;
};

Document Load(istream& input);
```
Требования:
* Содержимое библиотеки должно находиться в пространстве имён Ini
* Интерфейс, приведённый выше, должен быть объявлен в файле ini.h
* На проверку пришлите архив с полной реализацией библиотеки, в архиве должен быть файл ini.h
* В процессе тестирования функции Load ей на вход будет подаваться текст в формате
```
[секция 1]
ключ1=значение1
ключ2=значение2

[секция 2]
ключ3=значение3
ключ4=значение4
```
* Гарантируется, что в наших тестах используются только корректные ini-файлы, то есть строки вида ключ=значение всегда находятся внутри какой-то секции и содержат ровно один символ '='
* Строка ini-файла либо пустая, либо не содержит ведущих пробелов

Примеры применения библиотеки смотрите в юнит-тестах в файле test_ini.

## [Тренировочное задание по программированию: Рефакторинг чужого кода](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_4)

Продолжим работать с примером, в котором мы создавали программу учёта личных финансов и работали с форматами JSON и XML. На этот раз мы решили добавить в неё возможность конвертировать список расходов из XML в JSON и наоборот. Для этого мы написали две функции:

* Json::Document XmlToJson(const Xml::Document& doc)
* Xml::Document JsonToXml(const Json::Document& doc, string root_name)

Кроме того, мы покрыли их юнит-тестами в функциях TestXmlToJson и TestJsonToXml. Но есть одна проблема — весь этот код писал начинающий специалист, который посмотрел все лекции нашего курса, но, не решив ни одной задачи, сразу стал применять полученные знания в работе. Он обратился к вам за помощью, передал свой код и, сказав: «Что-то у меня не компилируется», ушёл в отпуск. Ваша задача — привести в порядок код его функций и тестов, то есть сделать так, чтобы они компилировались и работали.

Более подробно, функция XmlToJson ожидает на вход документ, имеющий структуру <root><spend amount="2500" category="food"></spend>...</root>, то есть в корневом узле лежит ноль или больше узлов с именем "spend" и атрибутами "amount" и "category". Она должна возвращать объект класса Json::Document, имеющий структуру [{"amount": 2500, "category": "food"}, ...], то есть это массив, содержащий столько словарей, сколько было узлов <spend> в XML-документе. При этом в словарях узёл по ключу "amount" должен быть целочисленным, а по ключу "category" — строковым. Гарантируется, что в тестирующей системе на вход вашей функции будут подаваться только XML-документы, соответствующие описанному формату (то есть обрабатывать некорректный ввод в данной задаче не надо).

Функция JsonToXml должна выполнять обратное преобразование. Точно так же в нашей тестирующей системе ей на вход будут подаваться только JSON-документы, соответствующие описанному формату.

Тесты TestXmlToJson и TestJsonToXml не должны принимать пустые реализации функций XmlToJson и JsonToXml, а также реализации, нарушающие формат выходных данных. Вам не надо добавлять в тесты другие тестовые случаи, надо заставить компилироваться и работать те, которые есть.

На проверку пришлите cpp-файл, который
* подключает файлы xml.h и json.h
* содержит реализацию функций XmlToJson, JsonToXml, TestJsonToXml, TestXmlToJson

Вам даны файлы xml.h/cpp и json.h/cpp, приведённые в соответствие с рекомендациями последней лекции. Именно они будут использоваться в процессе тестирования вашей посылки.


## [Задание по программированию: Реструктуризация кода](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_5)

В предыдущем видео мы показали, как пространства имён могут использоваться для структурирования кода и его разбиения на логические блоки. В этой задаче вам предстоит попрактиковаться в этом.

Вам дана программа, которая умеет вычислять различные агрегации набора целых чисел: минимум, максимум, сумму, среднее и моду. Каждая агрегация в программе реализована в виде отдельного класса, который является потомком абстрактного базового класса StatsAggregator. Эти классы имеют имена:
* SumStatsAggregator
* MinStatsAggregator
* MaxStatsAggregator
* AverageStatsAggregator
* ModeStatsAggregator

Как видите, у всех этих классов общий суффикс. Его частое использование может загромождать код и затруднять его читаемость (особенно это касается файла с реализацией классов и файла с тестами). Выполните следующие преобразования кода:

* удалите из имён потомков StatsAggregator общий суффикс (например, SumStatsAggregator надо переименовать в Sum)
* удалите из имён тестов общий суффикс (например, TestSumStatsAggregator надо переименовать в TestSum (см. юнит-тесты в файлах stats_aggregator.h и stats_aggregator_test.cpp ниже))
* поместите классы-потомки StatsAggregator, а также тесты для них в пространство имён StatsAggregators
* обновите файл main.cpp так, чтобы он корректно работал с новой структурой кода (в т.ч. вызывал юнит-тесты)
* базовый класс StatsAggregator оставьте в глобальном пространстве имён

Как говорилось в видео, перемещение базового класса в пространство имён является делом вкуса. В этой задаче мы просим оставить его в глобальном пространстве имён, потому что это позволяет не трогать код, который работает с абстрактным интерфейсом, а не с его реализациями. Ради эксперимента, после сдачи задачи, вы можете поместить StatsAggregator в пространство имён StatsAggregators и посмотреть, какой ещё код придётся поменять и станет ли он от этого изменения проще.

Как будет тестироваться ваш код

Пришлите на проверку архив с переработанными файлами исходной программы. Тестирование будет проходить в несколько этапов.

1. Сначала мы проверим, что в файле stats_aggregator.h есть классы StatsAggregator, StatsAggregators::Sum, StatsAggregators::Min, StatsAggregators::Max, StatsAggregators::Average, StatsAggregators::Mode и StatsAggregators::Composite, а также соответствующие функции с юнит-тестами.
2. Затем запустим наши внутренние юнит-тесты для классов-потомков StatsAggregator, чтобы убедиться, что они действительно реализуют его интерфейс.
3. Далее мы запустим ваши юнит-тесты из файла stats_aggregator_test.cpp и убедимся, что они срабатывают на неверных реализациях классов и принимают верные.
4. Наконец, мы соберём весь ваш проект и подадим ему в stdin несколько тестов, чтобы убедиться, что программа целиком работает корректно.

## [Задание по программированию: Двойная диспетчеризация](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_6)

Из лекций мы узнали, что this всегда указывает на текущий объект класса, а также, что он является неявным параметром всех его методов. Кроме того, мы только что познакомились с понятиями статического и динамического типов ссылки (или указателя). В этой задаче мы объединим эти знания, чтобы реализовать так называемую двойную диспетчеризацию — мы напишем функцию, которая ведёт себя по-разному в зависимости о динамических типов двух объектов, которые в неё переданы.

Представим, что мы пишем движок для классической компьютерной стратегии: игроки строят города, формируют армию, а потом сражаются друг с другом. В нашей игре есть несколько объектов:

* юниты — это солдаты, рабочие, кавалеристы и т.д.
* здания — фабрики, заводы, казармы и т.д.
* башни и стены — защитные сооружения для обороны своего города

Мы работаем над функциональностью размещения новых объектов на игровой карте. Допустим, мы хотим построить новое здание. Мы начинаем искать на карте место, где его можно разместить, а графический интерфейс игры нам в этом помогает. Здание можно построить в том месте карты, где нет других объектов. Если в текущей позиции здание пересекается с каким-то из объектов, то интерфейс рисует наше здание красным цветом, сообщая, что здесь его построить нельзя.

При этом юниты представляются точкой на плоскости, здания — прямоугольником, башни — кругом, а стены — отрезком. Кроме того, для каждого игрового объекта в нашем движке заведён отдельный класс, который наследуется от абстрактного класса GameObject:

```cpp
class Unit;
class Building;
class Tower;
class Fence;

struct GameObject {
  virtual ~GameObject() = default;

  virtual bool Collide(const GameObject& that) const = 0;
  virtual bool CollideWith(const Unit& that) const = 0;
  virtual bool CollideWith(const Building& that) const = 0;
  virtual bool CollideWith(const Tower& that) const = 0;
  virtual bool CollideWith(const Fence& that) const = 0;
};
```

Наша задача — реализовать функцию bool Collide(const GameObject& first, const GameObject& second), которая проверяет пересекаются ли два игровых объекта, то есть имеют ли они хотя бы одну общую точку.

Вам даны:

* файл game_object.h, содержащий интерфейс GameObject и объявление функции Collide
* файлы geo2d.h/cpp, содержащие библиотеку для работы с геометрическими фигурами на плоскости; библиотека состоит из классов Point, Rectangle, Circle и Segment и набора функций Collide, которые умеют определять пересечение для каждой пары фигур (занимательный факт — все функции реализованы в целых числах, без применения вычислений в типе double)
* файл collide.cpp, содержащий заготовку решения, а также юнит-тест, эмулирующий размещение нового объекта на игровой карте

Пришлите в тестирующую систему файл collide.cpp, который будет:

* подключать game_object.h
* содержать реализации классов Unit, Building, Tower и Fence (все они должны наследоваться от GameObject и реализовывать его интерфейс)
* содержать реализацию функции bool Collide(const GameObject& first, const GameObject& second), которая возвращает true, если объекты first и second имеют на плоскости хотя бы одну общую точку, и false в противном случае.

Замечание

Один из способов реализовать функцию Collide — использовать dynamic_cast. Мы не освещали его в лекциях. Кроме того, этот способ приводит к появлению развесистого кода, подверженного возникновению ошибок. Мы хотим, чтобы в этой задаче вы хорошенько разобрались с понятиями статического и динамического типа, а также поработали с указателем this. Поэтому мы будем компилировать ваши решения с флагом -fno-rtti, который будет приводить к ошибкам компиляции в случае использования dynamic_cast.

## [Задание по программированию: Сервер комментариев](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Brown%20Belt/Week_2/Task_7)

### Предисловие

В этой задаче мы разберём приём, известный как chaining, который широко применяется во многих языках программирования, особенно в JavaScript. В C++ chaining тоже имеет свою нишу применения. Указатель this необходим для реализации chaining'а. Кроме того, чтобы задача не выглядела искусственной, мы разберём применение этого приёма в реальной практической ситуации, с которой сталкивался один из преподавателей курса.

### Условие

Вы подключились к команде, которая разрабатывает web-сервер комментариев. Этот сервер позволяет создавать новых пользователей, публиковать новые объявления, а также читать все объявления выбранного пользователя. Кроме того команда недавно озаботилась борьбой со спамерами. Если какой-то пользователь признаётся спамером, он блокируется, после чего ему выдаётся страница капчи, на которой он должен подтвердить, что он человек. В случае успешного ввода капчи пользователь разблокируется и получает возможность снова оставлять комментарии.

Для выявления спамеров используется довольно простой алгоритм — спамером признаётся пользователь, отправивший три комментария подряд (см. реализацию сервера в заготовке решения).

Сервер работает по протоколу HTTP и обрабатывает следующие запросы:

* POST /add_user — добавляет нового пользователя и возвращает ответ 200 OK, в теле которого содержится идентификатор вновь добавленного пользователя (см. реализацию в заготовке решения)
* POST /add_comment — извлекает из тела запроса идентификатор пользователя и новый комментарий; если пользователь признаётся спамером, возвращает 302 Found c заголовком Location: /captcha, переводя пользователя на страницу капчи, в противном случае сохраняет комментарий и возвращает 200 OK
* GET /user_comments?user_id=[id] — возвращает ответ 200 OK, в теле которого содержатся все комментарии пользователя id, разделённые переводом строки
* GET /captcha — возвращает ответ 200 OK, в теле которого содержится страница капчи (для простоты в этой задаче мы просто возвращаем вопрос, на который надо ответить пользователю, на практике это может быть полноценная HTML-страница)
* POST /checkcaptcha — извлекает из тела запроса ответ на вопрос капчи; если он верен, разблокирует пользователя и возвращает 200 OK, если нет — возвращает 302 Found c заголовком Location: /captcha
* если метод запроса не POST и не GET или путь запроса не совпадает ни с одним из вышеперечисленных, сервер отвечает 404 Not found.

Web-сервер в коде реализован с помощью класса CommentServer:

```cpp
struct HttpRequest {
  string method, path, body;
  map<string, string> get_params;
};

class CommentServer {
public:
  void ServeRequest(const HttpRequest& req, ostream& response_output);

private:
  ...
};
```

Его метод ServeRequest принимает HTTP-запрос, обрабатывает его и записывает HTTP-ответ в выходной поток response_output (этот поток может быть привязан к сетевому соединению). При записи HTTP-ответа в выходной поток используется следующий формат:

```
HTTP/1.1 [код ответа] [комментарий]
[Заголовок 1]: [Значение заголовка 1]
[Заголовок 2]: [Значение заголовка 2]
...
[Заголовок N]: [Значение заголовка N]
<пустая строка>
[Тело ответа]
```

* код ответа — это 200, 302, 404 и т.д.
* комментарий — "Found", "OK", "Not found" и т.д.
* Заголовок X — имя заголовка, например, "Location"
* тело ответа — например, это содержимое страницы капчи или идентификатор вновь добавленного пользователя; при этом, если тело ответа непустое, в ответе обязательно должен присутствовать заголовок Content-Length, значение которого равно длине ответа в байтах.

Пример ответа на запрос /add_user, в котором возвращается идентификатор нового пользователя, равный 12. Content-Length равен 2, потому что "12" — это два символа:

```
HTTP/1.1 200 OK
Content-Length: 2

12
```

С нашим сервером есть проблема — иногда он ничего не отвечает на запросы, а иногда возвращает некорректно сформированные ответы. Источник этих проблем в том, что ответы формируются вручную каждый раз (см. заготовку решения). Из-за этого мы то перевод строки забыли, то добавили лишний, то в коде ответа опечатались:

```cpp
void ServeRequest(const HttpRequest& req, ostream& os) {
  if (req.method == "POST") {
    if (req.path == "/add_user") {
      comments_.emplace_back();
      auto response = to_string(comments_.size() - 1);
      os << "HTTP/1.1 200 OK\n" << "Content-Length: " << response.size() << "\n" << "\n"
        << response;
    } else if (req.path == "/checkcaptcha") {
       ...
        os << "HTTP/1.1  20 OK\n\n";
      }
    } else {
      os << "HTTP/1.1 404 Not found\n\n";
    }
  ...
}
```

Вы решили избавиться от всех проблем разом и провести следующий рефакторинг:

* разработать класс HttpResponse, который будет представлять собой HTTP-ответ; в operator << вы решили инкапсулировать формат вывода HTTP-ответа в поток
* сделать новую сигнатуру метода ServeRequest — HttpResponse ServeRequest(const HttpRequest& req), — которая на этапе компиляции будет гарантировать, что наш сервер всегда возвращает хоть какой-то ответ (если мы забудем это сделать, компилятор выдаст предупреждение "control reaches end of non-void function")
* записывать ответ сервера в выходной поток в одном единственном месте, в котором вызывается метод ServeRequest

Интерфейс класса HttpResponse вы решили сделать таким:

```cpp
enum class HttpCode {
  Ok = 200,
  NotFound = 404,
  Found = 302,
};

class HttpResponse {
public:
  explicit HttpResponse(HttpCode code);

  HttpResponse& AddHeader(string name, string value);
  HttpResponse& SetContent(string a_content);
  HttpResponse& SetCode(HttpCode a_code);

  friend ostream& operator << (ostream& output, const HttpResponse& resp);
};
```

Методы AddHeader, SetContent и SetCode должны возвращать ссылку на себя, чтобы иметь возможность сформировать ответ в одной строке с помощью chaining'а: return HttpResponse(HttpCode::Found).AddHeader("Location", "/captcha");. Перечисление HttpCode, передаваемое в конструктор класса HttpResponse, гарантирует, что мы не ошибёмся в коде ответа.

Этот рефакторинг вам и предстоит выполнить в этой задаче. Пришлите на проверку cpp-файл, который

* содержит реализацию класса HttpResponse,
* содержит реализацию класса CommentServer с публичным методом HttpResponse ServeRequest(const HttpRequest& req).

Сервер должен реализовывать описанный выше протокол.

Уточнения к реализации класса HttpResponse:

* Методы AddHeader, SetContent, SetCode должны возвращать ссылку на объект, для которого они вызваны
* Метод AddHeader всегда добавляет к ответу новый заголовок, даже если заголовок с таким именем уже есть
* operator<< для класса HttpResponse должен выводить HTTP-ответ в формате, описанном выше в описании метода ServerRequest; при этом заголовки можно выводить в произвольном порядке. Если у HTTP-ответа есть непустое содержимое, то необходимо вывести ровно один заголовок "Content-Length", значение которого равно размеру содержимого в байтах.
