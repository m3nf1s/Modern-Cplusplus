# Итераторы, алгоритмы и контейнеры

## [Тренировочное задание по программированию: Часть вектора](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_1)


Напишите функцию PrintVectorPart, принимающую вектор целых чисел numbers, выполняющую поиск первого отрицательного числа в нём и выводящую в стандартный вывод все числа, расположенные левее найденного, в обратном порядке. Если вектор не содержит отрицательных чисел, выведите все числа в обратном порядке.

```cpp
void PrintVectorPart(const vector<int>& numbers);
```

## [Задание по программированию: Часть множества](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_2)

Напишите шаблонную функцию FindGreaterElements, принимающую множество elements объектов типа T и ещё один объект border типа T и возвращающую вектор из всех элементов множества, бо́льших border, в возрастающем порядке.

```cpp
template <typename T>
vector<T> FindGreaterElements(const set<T>& elements, const T& border);
```

## [Задание по программированию: Разбиение на слова](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_3)

Напишите функцию SplitIntoWords, разбивающую строку на слова по пробелам.

```cpp
vector<string> SplitIntoWords(const string& s);
```

Гарантируется, что:
* строка непуста;
* строка состоит лишь из латинских букв и пробелов;
* первый и последний символы строки не являются пробелами;
* строка не содержит двух пробелов подряд.

### Подсказка
Рекомендуется следующий способ решения задачи:
* искать очередной пробел с помощью алгоритма find;
* создавать очередное слово с помощью конструктора строки по двум итераторам.

## [Тренировочное задание по программированию: Удаление повторов](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_4)

Напишите шаблонную функцию RemoveDuplicates, принимающую по ссылке вектор elements объектов типа T и удаляющую из него все дубликаты элементов. Порядок оставшихся элементов может быть любым.

Гарантируется, что объекты типа T можно сравнивать с помощью операторов ==, !=, < и >.

```cpp
template <typename T>
void RemoveDuplicates(vector<T>& elements);
```

## [Задание по программированию: Перебор перестановок](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_5)

Дано целое положительное число N, не превышающее 9. Выведите все перестановки чисел от 1 до N в обратном лексикографическом порядке (см. пример).

## [Тренировочное задание по программированию: Демографические показатели](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_6)


В этой задаче вам необходимо вычислить различные демографические показатели для группы людей. Человек представляется структурой Person:
```cpp
struct Person {
  int age;  // возраст
  Gender gender;  // пол
  bool is_employed;  // имеет ли работу
};
```

Тип Gender определён следующим образом:
```cpp
enum class Gender {
  FEMALE,
  MALE
};
```

Вам необходимо написать функцию PrintStats, получающую вектор людей, вычисляющую и выводящую медианный возраст для каждой из следующих групп людей:

* все люди;
* все женщины;
* все мужчины;
* все занятые женщины;
* все безработные женщины;
* все занятые мужчины;
* все безработные мужчины.

Все 7 чисел нужно вывести в строгом соответствии с форматом (см. пример).
```cpp
void PrintStats(vector<Person> persons);
```
Принимая вектор по значению (а не по константной ссылке), вы получаете возможность модифицировать его копию произвольным образом и тем самым проще произвести вычисления.

### Подсказка
Используйте алгоритм partition.

### Вычисление медианного возраста
Для вычисления медианного возраста группы людей вы должны использовать функцию ComputeMedianAge:
```cpp
template <typename InputIt>
int ComputeMedianAge(InputIt range_begin, InputIt range_end);
```

**Эту функцию не нужно реализовывать самостоятельно**: мы реализовали её за вас и автоматически добавим к каждому вашему решению.

Функцию ComputeMedianAge можно вызвать и для пустого набора людей: её результат в этом случае и нужно считать медианным возрастом пустого набора людей.

## [Задание по программированию: Сортировка слиянием](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_7)

Напишите шаблонную функцию MergeSort, принимающую два итератора шаблонного типа RandomIt и сортирующую заданный ими диапазон с помощью сортировки слиянием. Гарантируется, что:

* итераторы типа RandomIt аналогичны по функциональности итераторам вектора и строки, то есть их можно сравнивать с помощью операторов <, <=, > и >=, а также вычитать и складывать с числами;
* сортируемые объекты можно сравнивать с помощью оператора <.

### **Часть 1. Реализация с разбиением на 2 части**

### Алгоритм
Классический алгоритм сортировки слиянием выглядит следующим образом:

1. Если диапазон содержит меньше 2 элементов, выйти из функции.
2. Создать вектор, содержащий все элементы текущего диапазона.
3. Разбить вектор на две равные части. (В этой задаче гарантируется, что длина передаваемого диапазона является степенью двойки, так что вектор всегда можно разбить на две равные части.)
4. Вызвать функцию MergeSort от каждой половины вектора.
5. С помощью алгоритма merge слить отсортированные половины, записав полученный отсортированный диапазон вместо исходного.

Вы должны реализовать именно этот алгоритм и никакой другой: тестирующая система будет проверять, что вы выполняете с элементами именно эти действия.

### Подсказка
Чтобы создать вектор, содержащий все элементы текущего диапазона (п. 2 алгоритма), необходимо уметь по типу итератора узнавать тип элементов, на которые он указывает. Если итератор RandomIt принадлежит стандартному контейнеру (вектору, строке, множеству, словарю...), нижележащий тип можно получить с помощью выражения typename RandomIt::value_type. Таким образом, гарантируется, что создать вектор в п. 2 можно следующим образом:

### **Часть 2. Реализация с разбиением на 3 части**

Реализуйте сортировку слиянием, разбивая диапазон на 3 равные части, а не на 2. Гарантируется, что длина исходного диапазона является степенью 3.

Соответственно, пункты 3–5 алгоритма нужно заменить следующими:

* Разбить вектор на 3 равные части.
* Вызвать функцию MergeSort от каждой части вектора.
* Слить первые две трети вектора с помощью алгоритма merge, сохранив результат во временный вектор с помощью back_inserter.
* Слить временный вектор из предыдущего пункта с последней третью вектора из п. 2, записав полученный отсортированный диапазон вместо исходного.

## [Тренировочное задание по программированию: Поиск ближайшего элемента](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_8)

Напишите функцию FindNearestElement, для множества целых чисел numbers и данного числа border возвращающую итератор на элемент множества, ближайший к border. Если ближайших элементов несколько, верните итератор на наименьший из них.

```cpp
set<int>::const_iterator FindNearestElement(
    const set<int>& numbers,
    int border);
// set<int>::const_iterator —
// тип итераторов для константного множества целых чисел
```

## [Тренировочное задание по программированию: Имена и фамилии — 4](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_9)

Решите задачу «Имена и фамилии — 1» более эффективно, использовав двоичный поиск в методе Person::GetFullName. Напомним условие задачи.

Реализуйте класс для человека, поддерживающий историю изменений человеком своих фамилии и имени.

```cpp
class Person {
public:
  void ChangeFirstName(int year, const string& first_name) {
    // добавить факт изменения имени на first_name в год year
  }
  void ChangeLastName(int year, const string& last_name) {
    // добавить факт изменения фамилии на last_name в год year
  }
  string GetFullName(int year) {
    // получить имя и фамилию по состоянию на конец года year
    // с помощью двоичного поиска
  }
private:
  // приватные поля
};
```

Считайте, что в каждый год может произойти не более одного изменения фамилии и не более одного изменения имени. При этом с течением времени могут открываться всё новые факты из прошлого человека, поэтому года́ в последовательных вызовах методов ChangeLastName и ChangeFirstName не обязаны возрастать.

Гарантируется, что все имена и фамилии непусты.

Строка, возвращаемая методом GetFullName, должна содержать разделённые одним пробелом имя и фамилию человека по состоянию на конец данного года.

* Если к данному году не случилось ни одного изменения фамилии и имени, верните строку "**Incognito**".
* Если к данному году случилось изменение фамилии, но не было ни одного изменения имени, верните "***last_name*** **with unknown first name**".
* Если к данному году случилось изменение имени, но не было ни одного изменения фамилии, верните "***first_name*** **with unknown last name**".
## [Задание по программированию: Группировка строк по префиксу](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_10)

### Часть 1. Группировка по символу
Напишите функцию FindStartsWith:

* принимающую отсортированный набор строк в виде итераторов range_begin, range_end и один символ prefix;
* возвращающую диапазон строк, начинающихся с символа prefix, в виде пары итераторов.

```cpp
template <typename RandomIt>
pair<RandomIt, RandomIt> FindStartsWith(RandomIt range_begin, RandomIt range_end, char prefix);
```

Если итоговый диапазон пуст, его границы должны указывать на то место в контейнере, куда можно без нарушения порядка сортировки вставить любую строку, начинающуюся с символа prefix (подобно алгоритму equal_range). Гарантируется, что строки состоят лишь из строчных латинских букв и символ prefix также является строчной латинской буквой.

Поиск должен осуществляться за логарифмическую сложность — например, с помощью двоичного поиска.

### Часть 2. Группировка по префиксу
Напишите более универсальный вариант функции FindStartsWith, принимающий в качестве префикса произвольную строку, состоящую из строчных латинских букв.

```cpp
template <typename RandomIt>
pair<RandomIt, RandomIt> FindStartsWith(RandomIt range_begin, RandomIt range_end, const string& prefix);
```
## [Задание по программированию: Построение арифметического выражения](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_4/Task_11)

### Часть 1
Реализуйте построение арифметического выражения согласно следующей схеме:

* изначально есть выражение, состоящее из некоторого целого числа x;
* на каждом шаге к текущему выражению применяется некоторая операция: прибавление числа, вычитание числа, умножение на число или деление на число; перед применением операции выражение всегда должно быть заключено в скобки.

### Формат ввода
В первой строке содержится исходное целое число x. Во второй строке содержится целое неотрицательное число N— количество операций. В каждой из следующих N строк содержится очередная операция:

* прибавление числа a: + a;
* либо вычитание числа b: - b;
* либо умножение на число c: * c;
* либо деление на число d: / d.
Количество операций может быть нулевым — в этом случае необходимо вывести исходное число.

### Формат вывода
Выведите единственную строку — построенное арифметическое выражение.

Обратите внимание на расстановку пробелов вокруг символов:

* каждый символ бинарной операции (+, -, * или /) должен быть окружён ровно одним пробелом с каждой стороны: (8) * 3;
* символ унарного минуса (для отрицательных чисел) не нуждается в дополнительном пробеле: -5;
* скобки и числа не нуждаются в дополнительных пробелах.
### Подсказка
Для преобразования числа к строке используйте функцию to_string из библиотеки <string>.

### Часть 2. Без лишних скобок
Модифицируйте решение предыдущей части так, чтобы предыдущее выражение обрамлялось скобками лишь при необходимости, то есть только в том случае, когда очередная операция имеет бо́льший приоритет, чем предыдущая.

