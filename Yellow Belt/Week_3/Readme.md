# Распределение кода по файлам

## [Задание по программированию: Реализовать функции, объявленные в заголовочном файле](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_3/Task_1)

Вам дан заголовочный файл sum_reverse_sort.h, содержащий объявления трёх функций
```cpp
#pragma once
#include <string>
#include <vector>

using namespace std;

int Sum(int x, int y);
string Reverse(string s);
void Sort(vector<int>& nums);
```

Вам надо прислать cpp-файл, содержащий определения этих функций.

### Как будет тестироваться ваш код
Автоматическая тестирующая система добавит ваш cpp-файл в проект, содержащий другой cpp-файл с юнит-тестами для всех трёх функций, а также файл sum_reverse_sort.h. Затем она соберёт этот проект и, если компиляция будет выполнена успешно, запустит получившийся исполняемый файл. Если он завершится успешно (т. е. юнит-тесты не найдут ошибок в вашей реализации), то ваша посылка будет засчитана.

## [Задание по программированию: Реализовать класс, объявленный в заголовочном файле](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_3/Task_2)

Вам дан заголовочный файл phone_number.h, содержащий объявление класса PhoneNumber. При этом в комментариях описано поведение, которое ожидается от реализации этого класса.

```cpp
#pragma once

#include <string>

using namespace std;

class PhoneNumber {
public:
  /* Принимает строку в формате +XXX-YYY-ZZZZZZ
     Часть от '+' до первого '-' - это код страны.
     Часть между первым и вторым символами '-' - код города
     Всё, что идёт после второго символа '-' - местный номер.
     Код страны, код города и местный номер не должны быть пустыми.
     Если строка не соответствует этому формату, нужно выбросить исключение invalid_argument.
     Проверять, что номер содержит только цифры, не нужно.

     Примеры:
     * +7-495-111-22-33
     * +7-495-1112233
     * +323-22-460002
     * +1-2-coursera-cpp
     * 1-2-333 - некорректный номер - не начинается на '+'
     * +7-1233 - некорректный номер - есть только код страны и города
  */
  explicit PhoneNumber(const string &international_number);

  string GetCountryCode() const;
  string GetCityCode() const;
  string GetLocalNumber() const;
  string GetInternationalNumber() const;

private:
  string country_code_;
  string city_code_;
  string local_number_;
};
```

Пришлите cpp-файл с определениями методов класса PhoneNumber, которые реализуют описанное поведение.

### Как будет тестироваться ваш код
Автоматическая тестирующая система добавит ваш cpp-файл в проект, содержащий другой cpp-файл с юнит-тестами для класса PhoneNumber, а также файл phone_number.h. Затем она соберёт этот проект и, если компиляция будет выполнена успешно, запустит получившийся исполняемый файл. Если он завершится успешно (т. е. юнит-тесты не найдут ошибок в вашей реализации), то ваша посылка будет засчитана.

## [Тренировочное задание по программированию: Написать объявление класса](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_3/Task_3)

Вам дано полное определение класса Rectangle

```cpp
class Rectangle {
public:
    Rectangle(int width, int height) : width_(width), height_(height)
    {
    }

    int GetArea() const {
        return width_ * height_;
    }

    int GetPerimeter() const {
        return 2 * (width_ + height_);
    }

    int GetWidth() const { return width_; }
    int GetHeight() const { return height_; }

private:
    int width_, height_;
};
```

Пришлите заголовочный файл rectangle.h, содержащий объявление класса Rectangle. Это должен быть полноценный заголовочный файл, который можно использовать в большом проекте. В частности, в нём должна быть решена проблема двойного включения.

## [Задание по программированию: Декомпозиция программы — 2](https://github.com/m3nf1s/Modern-Cplusplus/tree/master/Yellow%20Belt/Week_3/Task_4)

В задаче «Декомпозиция программы» мы разбили монолитный код на набор функций и классов. Теперь мы сделаем ещё один шаг и разделим нашу программу на несколько файлов. В этой задаче вам нужно создать проект, состоящий из следующих файлов:

1. query.h, в него кладём:
    * enum class QueryType
    * struct Query
    * объявление istream& operator >> (istream& is, Query& q)
    
2. query.cpp, в него кладём
    * определение istream& operator >> (istream& is, Query& q);
    
3. responses.h:
    * struct BusesForStopResponse
    * ostream& operator << (ostream& os, const BusesForStopResponse& r)
    * struct StopsForBusResponse
    * ostream& operator << (ostream& os, const StopsForBusResponse& r)
    * struct AllBusesResponse
    * ostream& operator << (ostream& os, const AllBusesResponse& r)
4. responses.cpp: определения всего, что объявлено в responses.h

5. bus_manager.h: объявление класса BusManager

6. bus_manager.cpp: определения методов класса BusManager

7. main.cpp: функция main

### Как отправлять проект на проверку
В заданиях по программированию Coursera позволяет отправлять на проверку только один файл, поэтому для того, чтобы сдать свой проект в тестирующую систему, вам надо запаковать все свои файлы в архив и отправить его на проверку. Поддерживаемые форматы архивов: rar, zip, 7z, tar, tar.gz, а также многие другие (для распаковки мы используем программу dtrx, на странице с её описанием приведён полный список поддерживаемых форматов).

### Как будет тестироваться ваше решение
Ниже вам дана заготовка для файла main.cpp, содержащая функцию main. Это точно такая же заготовка, которая была дана в задаче «Декомпозиция программы». Тестирование вашего решения будет выполняться в два этапа. На первом этапе автоматическая тестирующая система распакует присланный вами архив и соберёт извлечённые файлы в исполняемый файл. При этом функция main в вашем проекте будет заменена на ту, которая дана в заготовке файла main.cpp. Затем этот исполняемый файл будет запущен на наборе тестов. Тестирование выполняется так же, как и для большинства задач на нашем курсе: тест подаётся в stdin, замеряется время выполнения программы, а затем анализируется stdout.

На втором этапе будет выполняться тестирование отдельных файлов вашего проекта. Проверяется, что файл query.h действительно содержит перечислимый тип QueryType, что BusManager::GetBusesForStop возвращает корректно сформированный объект BusesForStopResponse т.д.
